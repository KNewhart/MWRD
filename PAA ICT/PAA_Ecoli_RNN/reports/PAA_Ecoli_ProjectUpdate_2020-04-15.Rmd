---
title: "Predisinfection E. coli Modeling"
subtitle: "Analysis and Prediction"
date: "2020-04-15"
output:
  word_document:
     reference_docx: C:/Users/kbnewhart/Dropbox/Code/MWRD/PAA ICT/PAA_Ecoli_RNN/src/word_template.docx
bibliography: C:/Users/kbnewhart/Dropbox/Code/MWRD/PAA ICT/PAA_Ecoli_RNN/src/bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.path="figures/", fig.align="center", fig.fullwidth=TRUE, dev = 'png', dpi=600, fig.width = 6.5, family="serif")

# Change working directory to be "Ecoli_RNN", rather than location of notebook
# wd.path <- "C:/Users/KNewhart/Documents/GitHub/MWRD/PAA ICT/Ecoli_RNN/"
wd.path <- getwd()
if(tail(unlist(strsplit(wd.path,"/")),n=1)!="Ecoli_RNN") wd.path <- dirname(wd.path)
knitr::opts_knit$set(root.dir = wd.path)

library(flextable)
library(dplyr)
theme_kate <- function(x, fontsize = 12){
  if( !inherits(x, "flextable") ) stop("theme_kate supports only flextable objects.")
  
  big_border <- officer::fp_border(width = 1)
  std_border <- officer::fp_border(width = 1)
  h_nrow <- flextable:::nrow_part(x, "header")
  f_nrow <- flextable:::nrow_part(x, "footer")
  b_nrow <- flextable:::nrow_part(x, "body")

  x <- border_remove(x)

  if(h_nrow > 0 ){
    x <- hline_top(x, border = big_border, part = "header")
    x <- hline(x, border = std_border, part = "header")
    x <- hline_bottom(x, border = big_border, part = "header")
    x <- bold(x = x, bold = TRUE, part = "header")
  }
  if(f_nrow > 0 ){
    # x <- hline(x, border = std_border, part = "footer")
    x <- hline_bottom(x, border = big_border, part = "footer")
  }
  if(b_nrow > 0 ){
    # x <- hline(x, border = std_border, part = "body")
    x <- hline_bottom(x, border = big_border, part = "body")
  }

  x <- padding(x = x, padding.left = 4, padding.right = 4,
               padding.bottom = 1, padding.top = 1, part = "all")
  x <- align_text_col(x, align = "left", header = TRUE)
  x <- align_nottext_col(x, align = "right", header = TRUE)
  x <- bg(x = x, bg = "transparent", part = "all")
  x <- fontsize(x, size = fontsize, part = "all")
  x <- font(x, fontname="Times", part="all")
  x <- autofit(x)
  x
}
tab <-0;fig<-0
```


# Introduction

## Traditional WWTP disinfection process and control

### Regulations
* *E. coli*
  * WTD/MTD
  * Measured in the lab, results two-days later. 
  * Real-time instrumentation is too costly for even the largest municipal WWTPs

### Disinfectant
* Chlorine
  * Pros: Cheap
  * Cons: Produces DBPs that are harmful to aquatic life that receive the waters and human life when drinking water sources are threatended
* PAA
  * Pros: Fewer DBP
  * Cons: Difficult to control, does not follow same simple decay kinetics as chlorine

### Control
* Flow-paced
  * Caculated dose based on mass flow rate to achieve concentration setpoint, easy to operate
  * Does not account for instantaneous chemical demand or decay changes due to changing water quality, leads to overdosing during periods of low flow
* CT-based
  * Calculates dose based on mass flow rate and retention time to achieve a CT setpoint, more difficult to program
  * Relies on fitting of first order kinetic parameters that change with time.
  * Online analyzers are costly to purchase and maintain, reactive

## Machine learning approaches to disinfection modeling
* Literature review of PAA
  * ANN modeling of chlorine dosing and residuals has been widely explored for drinking water (@serodes2001) and wastewater treatment (@gibbs2006). 
  * @wei2017 was able to replicate a CFD-based PAA disinfection model (a chemically reactive time-dependent three-dimensional turbulent flow model) for a conventional 5-pass disinfection basin, using physical mixing and chemical decay kinetic parameters as ANN model inputs. The ANN was very simple, 11 inputs, 1-4 nodes in the hidden layer, and 2 outputs, fit by 40 observations and tested on 14. 
* Literature review of *E. coli*
  * E.coli disinfection by chlorine and PAA follow an *n*th order kinetic reaction... 
  * Most results are for total coliforms, not *E. coli*:
  * @lin2012 used an ANN to predict effluent total coliforms in a bench-scale UV disinfection system (combined with a linear model of UV dose and log inactivation) to control disinfection. However, the authors defend the strength of their model by the correlation coeffient (R^2^) between measured and predicted values rather than the magnitude of the error (e.g., root-mean-squared-error or RMSE). In practice, the error surrounding two of the three goal effluent total coliform counts was large (208-278 and 583-778 measured effluent total coliform counts, for the 200 and 1000 CFU/100 mL goals respectively). The third goal to achieve nondetect concentrations achieved a range of 0-25 CFU/100 mL).
  * @yu2008 used ANN to control a bench-scale chlorination-dechlorination system. 5 ANN models were built from pH and ORP in the influent, chlorination reactor and dechlorination reactor.  The first model predicted the chlorine dose based on the influent quality and target effluent total coliform for feedforward control. The second model predicted effluent total coliform from the actual chlorine dose (5 minute delay from dose change predicted by first model) and influent quality to provide feedback control. A similar combination of dose-response models were built for dechlorination. Total coliform goals were acheived for a variety of reuse scenerios, but residual chlorine was much more difficult to achieve precise control. 
  * @carvajal2017 investigated the realtionship between dose, time, pH, turbidity, and viral log inactivation on a bench-scale batch chlorination system for secondary treated wastewater using a Bayesian belief network (BBN). @carvagal2017 seeded water with viruses and measured log inactivation to train Bayesian multilayer perceptron (BMLP) models to predict the required CT, one for each type of virus. 



<!-- @Lin2012: Also used high number of epochs for a very low number of samples, two layers: 8-6/5-1 -->
  
* Artificial neural networks (ANN) are a nonlinear modeling method that identifies patterns between input and output data by (1) using a large number of obervations, (2) mulitple nonlinear functions that combine different process variables, (3) trial-and-error to adjust the parameters of the nonlinear functions to accurately map input to output. 
* ANN are not constructed for time-series data, i.e., correlation to previous timesteps. Recurrent neural networks (RNN) have internal memory nodes that can train based on a *sequence* of observations rather than a series of individual observations. Long short-term memory (LSTM) nodes are one example of a RNN that have been used in process data. 

## Objectives
* Need a cheap, real-time measure of PAA and E.coli concentrations for accurate disinfection control in WWTP
  * Need to understand the environmental and operational conditions that impact (1) PAA demand and decay and (2) pre- and post-disinfection E.coli.
  * Need to use unconventional modeling approaches, such as RNN, to (1) estimate first order decay parameters for PAA and (2) model *E. coli* removal

# Materials and Methods

## RWHTP
  * Two separate treatment trains: North and South 
  * Data collected:
    * PAA profiles from X-Y
    * Daily E. coli measurements from X-Y
    * Online instrumentation of upstream treatment processes
    * Daily-weekly samples of upstream treatment processes, both instantaneous grab and 24-hour flow-weighted composites

```{r Import data and functions, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(xts)
mergeData <- function(list.x, sort.by = 1, average = FALSE) {
  all.data <- do.call(merge, list.x)
  all.data.index <- which(!is.na(all.data[,sort.by]))
  for(i in 1:(length(all.data.index)-1)) {
    row.start <- all.data.index[i]
    row.stop <- all.data.index[i+1]
    if((row.stop-row.start) == 1) {
      next
    }
    if(!average) data.locf <- na.locf(all.data[(row.start+1):row.stop,])
    if(average) {
      data.avg <- t(data.frame(sapply(all.data[(row.start+1):row.stop,], function(x) mean(na.omit(x)))))
      rownames(data.avg) <- as.character(index(all.data)[row.stop])
      
    }
    if (!exists("new.data")) {
      if(!average) new.data <- data.frame(data.locf[nrow(data.locf),])
      if(average) new.data <- data.avg
    }
    if (exists("new.data")) {
      if(!average) new.data <- rbind(new.data, data.frame(data.locf[nrow(data.locf),]))
      if(average) new.data <- rbind(new.data, data.avg)
    }
  }
  new.data <- na.omit(new.data)
  na.fix <- which(!is.na(as.POSIXct(rownames(new.data), format = "%Y-%m-%d %H:%M:%S")))
  new.data.xts <- xts(new.data[na.fix,], order.by = as.POSIXct(rownames(new.data)[na.fix], format = "%Y-%m-%d %H:%M:%S"))
  
  return(new.data.xts)
}

##### PAA Process Data - Grab #####
delta <- intToUtf8(0x0394)
# Daily data
process.data <- readxl::read_excel("data/paa/PAA PROFILE DATA_08-12-18.xlsx", 
                                   sheet = "Process Data", skip = 1)
process.data <- process.data[-1,]
n.paa.grab <- xts::xts(apply(process.data[,c(12:17,19:27)], 2, function(x) as.numeric(x)), order.by =  as.POSIXct(as.data.frame(process.data[,18])[,1], format = "%Y-%m-%d %H:%M:%S"))
colnames(n.paa.grab) <- c("PAA Dosing Pump Total Flow (gpm)", #1 
                          "PAA Dose (mg/L)", #2
                          "PAA Setpoint (mg/L)", #3 
                          "Upstream  Residual (mg/L)", #4 
                          # paste0(delta,"PAA (mg/L)"),	#5
                          "deltaPAA (mg/L)", #5
                          "Pre-Disinfection E. coli (MPN/100 mL)",  #6
                          "Effluent Discharge (MGD)", #7
                          "Contact Tank Volume (MG)", #8
                          "Detention Time (min)", #9
                          "Time to Upstream Sample Point (min)", #10
                          "Log Removal (N0/N)", #11
                          "Effluent E. coli (MPN/100 mL)", #12
                          "CT (mg/L*min)", #13
                          "CuT (mg/L*min)", #14
                          "Ambient Temperature")#15
colnames(n.paa.grab) <- stringr::str_replace_all(colnames(n.paa.grab), c(" " = ".", "/" = "." , "-" = "","[(]" = "", "[)]" = "", "[*]"="."))
rm(process.data)


##### October PAA Process Data - Grab #####
oct.paa <- readxl::read_excel("data/paa/PAA PROFILE DATA_08-12-18.xlsx", 
                              sheet = "Oct 2 to 15, 2018", range = "A1:V170")[-1,]
n.datetime <- which(colnames(oct.paa) == "Date and Time")
oct.paa.index <- oct.paa[,n.datetime]
oct.paa <- sapply(oct.paa[,-n.datetime], function(x) as.numeric(x))
colnames(oct.paa) <- stringr::str_replace_all(colnames(oct.paa), c(" " = "." , "-" = "" ))
oct.paa <- xts(oct.paa, order.by = oct.paa.index[[1]])

###### North Carbovis Data #####
vis.data <- readxl::read_excel("data/paa/NNE Carbovis Data 2018.xlsx",
                               sheet = "Inst DL Data", col_types = c("date",
                                                                     "text", "numeric", "skip", "skip",
                                                                     "skip", "numeric", "skip", "skip",
                                                                     "skip", "numeric", "skip", "skip",
                                                                     "skip", "numeric", "skip", "skip",
                                                                     "skip", "numeric", "skip", "skip",
                                                                     "skip", "numeric", "skip", "skip",
                                                                     "skip", "skip", "numeric", "skip",
                                                                     "skip", "skip", "numeric", "skip",
                                                                     "skip", "skip", "skip", "numeric",
                                                                     "skip", "skip", "skip", "numeric",
                                                                     "skip"), skip = 6)
vis.data <- vis.data[which(vis.data[,2] == "Valid"),-2]
colnames(vis.data) <- c("Time", "CODto (mg/L)", "CODto (V)",
                        "TSS (mg/L)", "TSS (V)",
                        "UVT (%)", "UVT (V)",
                        "CODds (mg/L)", "CODds (V)",
                        "SACto (1/m)", "SACto (V)")
vis.data <- xts(vis.data[,-1], order.by = as.POSIXct(as.data.frame(vis.data[,1])[,1], format = "%Y-%m-%d %H-%M-%S"))


##### North Secondary - Online #####
## North secondary online
nsec.online <- as.data.frame(suppressWarnings(readxl::read_excel("data/paa/North Secondary and Disinfection Process Data_2018.xlsx", sheet = "NSEC Online Data", col_names = FALSE,
                                                                 col_types = c("date", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric", 
                                                                               "numeric", "numeric", "numeric"), 
                                                                 skip = 4)))
nsec.online <- xts(nsec.online[,-1], order.by = nsec.online[,1])
colnames(nsec.online) <- c("NSEC Influent Flow", "NSEC Influent Temp","NSEC Influent NH3","NSEC Influent TSS","NSEC Influent COD",
                           "NSEC CaRRB-1 Centrate Flow","NSEC CaRRB-1 NH3","NSEC CaRRB-3 Centrate Flow","NSEC CaRRB-3 NH3",
                           "GTE Flow","GTE to SSEC Flow","GTE to NSEC Flow",
                           "AB-10 Influent Flow","AB-10 A-Pass Temp","AB-10 A-Pass pH","AB-10 A-Pass DO","AB-10 A-Pass NH3","AB-10 A-Pass NO3","AB-10 B-Pass DO","AB-10 C-Pass pH	AB-10","C-Pass DO","AB-10 C-Pass NH3","AB-10 C-Pass NO3","AB-10 MLSS","AB-10 MLR Flow","Quad 4 RAS Flow","Quad 4 Basins in Service","AB-10 RAS Flow","NSEC Aerobic SRT",
                           "NSEC Effluent NH3","NSEC Effluent NO3","NSEC Effluent OP","NSEC Effluent TSS","NSEC Effluent NO5","NSEC Effluent Flow")


# nsec.online <- nsec.online["2018-11-04/2018-12-01"]
cols2remove <- c("NSEC CaRRB-1 Centrate Flow","NSEC CaRRB-1 NH3","NSEC CaRRB-3 Centrate Flow","NSEC CaRRB-3 NH3","GTE Flow","GTE to SSEC Flow","GTE to NSEC Flow")

nsec.online <- nsec.online[,-sapply(cols2remove, function(x) which(colnames(nsec.online) == x))]

more.nsec <- readxl::read_excel("data/paa/PAA-Ecoli.xlsx", 
                                sheet = "Sheet1", col_types = c("date", 
                                                                "numeric", "numeric", "numeric", 
                                                                "numeric", "numeric", "numeric", 
                                                                "numeric", "numeric", "numeric", 
                                                                "numeric", "numeric"))
more.nsec <- more.nsec[which(!is.na(more.nsec[,1])),]
more.nsec <- xts(more.nsec[,-1], order.by = more.nsec[,1][[1]])
colnames(more.nsec) <- c("PAA Upstream Residual", "PAA Total Flow", "Dis North Flow", 
                         "Temperature NSEC Inf", "ASRT", "NSEC Effluent NH3",
                         "NSEC Effluent NO3","NSEC Effluent OP","NSEC Effluent TSS",
                         "NSEC Effluent NO5","NSEC Effluent Flow")

all.data <- oct.paa
r <- paste0(range(index(all.data))[1],"/",range(index(all.data))[2])
all.data <- mergeData(list.x = list(all.data,vis.data[r],nsec.online[r,22:28]))
all.data <- na.omit(all.data)
remove.cols.names <- c("Initial.PAA.Demand.or.Decay", "DPAA.Samples","Sample.Time..1_min.","Detention.Time","PAA.Pump.Total.Flow", "PAA.Set.Point.Dose.Algorithm", "...10" , "Volume.to.1.min..Sample" , "Time.to.1.min..Sample", "Total.Basin.Volume", "DT.of.1.2.Basin", "SPBased.Disinfection.CT",     "CalcBased.Disinfection.CT", "CODto..V.", "CODds..V.", "TSS..V.", "UVT..V.", "UVT..V.", "SACto..V.")
remove.cols <- sapply(remove.cols.names, function(x) which(colnames(all.data) == x))
all.data <- all.data[,-remove.cols]
paa.data <- all.data
```

<!-- **Table `r tab<-tab+1;tab`.** Monitored process variables included in building nerual network model to predict PAA. -->
```{r Table of variables, eval=FALSE, include=FALSE}
library(dplyr)
all.data.names <- colnames(all.data) %>% gsub("[.]"," ", .) %>% gsub("  "," ", .) %>% gsub("  "," ", .)
data <- data.frame("North Variable"=all.data.names,
                   "Collection Method"=c("Online", "Grab", "Grab", rep("Online", 17)),
                    "Number of Observations"=apply(all.data,2,function(x) length(which(!is.na(x)))),
                    stringsAsFactors = FALSE)

colnames(data) <- c("North Variable", "Collection Method", "Number of Observations")
ft <- flextable(data)
ft <- theme_kate(ft)
ft <- align(ft, align="left", part="all")
ft
```

    
### *E. coli* model input data

```{r Import data, include=FALSE}
source("src/compile-data.R")
north.data <- compile.data("data/north/average")
south.data <- compile.data("data/south/average")
```
Data from the North and South that are used to predict *E. coli* are summaried below in Tables `r tab<-tab+1;tab.n.var <- tab;tab.n.var` and `r tab<-tab+1;tab.s.var <- tab;tab.s.var`. Figures `r fig<-fig+1;fig.n.ecoli<-fig;fig.n.ecoli` and `r fig<-fig+1;fig.s.ecoli<-fig;fig.s.ecoli` show the predisinfection *E. coli* and the log~10~-transformed predisinfection *E. coli* as a timeseries and boxplot. The boxplot illustrates that the raw predisinfection *E. coli* is heavily skewed (i.e., many outliers on one side of the median). By using a log~10~-transformation, the data is more normally distributed. 

**Table `r tab.n.var`.** Variables monitored in the North to predict E. coli performance. Number of observations is calculated by the number of variables that have a value collected within 24-hours prior to the E.coli sample

```{r Table north variables, warning=FALSE}
north.variables <- sapply(strsplit(unlist(strsplit(colnames(north.data), "_FC24")), "_G"), function(x) gsub("_"," ",gsub("[.]"," ", x)))
north.variables <- sapply(north.variables, function(x) {
  i <- 1
  while(!is.na(as.numeric(substr(x,1,i)))) i <- i+1
  if(!is.na(as.numeric(substr(x,i,i)))) {
    j <- i
    while(!is.na(as.numeric(substr(x,i,j)))) j <- j+1
    if(!is.na(as.numeric(substr(x,j,j)))) {
      k <- j
      while(!is.na(as.numeric(substr(x,j,k)))) k <- k+1
      return(substr(x,k,nchar(x)))
    } else {
      return(substr(x,j,nchar(x)))
    }
  } else {
    return(substr(x,i, nchar(x)))
  }
})
data <- data.frame(north.variables,
                   rep("Online",ncol(north.data)),
                    apply(north.data,2,function(x) length(which(!is.na(x)))),
                    stringsAsFactors = FALSE)
data[grep("FC24",colnames(north.data)),2] <- "FC24"
data[grep("_G",colnames(north.data)),2] <- "Grab"
colnames(data) <- c("North Variable", "Collection Method", "Number of Observations")
ft <- flextable(data)
ft <- theme_kate(ft)
ft <- align(ft, align="left", part="all")
ft <- width(ft, j=1:3, width = c(3.35, 1.37, 1.78))
ft
```



**Figure `r fig.n.ecoli`.** North predisinfection *E. coli* for training (before purple line) and testing (after purple line) period. A log~10~-transform approximates normally distributed training and testing data. 

```{r}
# layout.matrix <- matrix(c(1,2,3,3,4,4), nrow=3, byrow=TRUE)
# layout(mat=layout.matrix)
layout.matrix <- matrix(c(1,2,3,4), ncol=2, byrow=TRUE)
layout(mat=layout.matrix, widths = c(0.67, 0.33))
par(mar=c(3,2,2.1,1.5),family="serif")
plot(north.data$ECIDX_G, ylab="")
mtext("Predis E. coli (CFU/mL)", side=3,line=.5, font=2)
abline(v=index(north.data)[ceiling(nrow(north.data)*0.9)], col="purple")

par(mar=c(1,2,2,1), family="serif")
boxplot(as.vector(north.data$ECIDX_G))
mtext("Predis E.coli (CFU/mL)", side=3, line=0.5, font=2)

par(mar=c(3,2,2.1,1.5),family="serif")
plot(log10(north.data$ECIDX_G), ylab="")
mtext("LOG10 Predis E. coli", side=3,line=.5, font=2)
abline(v=index(north.data)[ceiling(nrow(north.data)*0.9)], col="purple")

par(mar=c(1,2,2,1), family="serif")
boxplot(as.vector(log10(north.data$ECIDX_G)))
mtext("LOG10 Predis E.coli", side=3, line=0.5, font=2)
```



**Table `r tab.s.var`.** Variables monitored in the South to predict predisinfection *E. coli* performance. Number of observations is calculated by the number of variables that have a value collected within 24-hours prior to the *E. coli* sample

```{r Table sorth variables, warning=FALSE}
south.variables <- sapply(strsplit(unlist(strsplit(colnames(south.data), "_FC24")), "_G"), function(x) gsub("_"," ",gsub("[.]"," ", x)))
south.variables <- sapply(south.variables, function(x) {
  i <- 1
  while(!is.na(as.numeric(substr(x,1,i)))) i <- i+1
  if(!is.na(as.numeric(substr(x,i,i)))) {
    j <- i
    while(!is.na(as.numeric(substr(x,i,j)))) j <- j+1
    if(!is.na(as.numeric(substr(x,j,j)))) {
      k <- j
      while(!is.na(as.numeric(substr(x,j,k)))) k <- k+1
      return(substr(x,k,nchar(x)))
    } else {
      return(substr(x,j,nchar(x)))
    }
  } else {
    return(substr(x,i, nchar(x)))
  }
})
data <- data.frame(south.variables,
                   rep("Online",ncol(south.data)),
                    apply(south.data,2,function(x) length(which(!is.na(x)))),
                    stringsAsFactors = FALSE)
data[grep("FC24",colnames(south.data)),2] <- "FC24"
data[grep("_G",colnames(south.data)),2] <- "Grab"
colnames(data) <- c("Sorth Variable", "Collection Method", "Number of Observations")
ft <- flextable(data)
ft <- theme_kate(ft)
ft <- align(ft, align="left", part="all")
ft <- width(ft, j=1:3, width = c(3.35, 1.37, 1.78))
ft
```

**Figure `r fig.s.ecoli`.** South predisinfection *E. coli* for training (before purple line) and testing (after purple line) period. A log~10~-transform approximates normally distributed training and testing data. 

```{r}
# layout.matrix <- matrix(c(1,2,3,3,4,4), nrow=3, byrow=TRUE)
# layout(mat=layout.matrix)
layout.matrix <- matrix(c(1,2,3,4), ncol=2, byrow=TRUE)
layout(mat=layout.matrix, widths = c(0.67, 0.33))
par(mar=c(3,2,2.1,1.5),family="serif")
plot(south.data$ECIDX_G, ylab="")
mtext("Predis E. coli (CFU/mL)", side=3,line=.5, font=2)
abline(v=index(south.data)[ceiling(nrow(south.data)*0.9)], col="purple")

par(mar=c(1,2,2,1), family="serif")
boxplot(as.vector(south.data$ECIDX_G))
mtext("Predis E.coli (CFU/mL)", side=3, line=0.5, font=2)

par(mar=c(3,2,2.1,1.5),family="serif")
plot(log10(south.data$ECIDX_G), ylab="")
mtext("LOG10 Predis E. coli", side=3,line=.5, font=2)
abline(v=index(south.data)[ceiling(nrow(south.data)*0.9)], col="purple")

par(mar=c(1,2,2,1), family="serif")
boxplot(as.vector(log10(south.data$ECIDX_G)))
mtext("LOG10 Predis E.coli", side=3, line=0.5, font=2)
```


## Recurrent neural networks
* First 90% of data is used to train a recurrent nerual network (RNN)
* Last 10% of data is used to test RNN
* Single layer of *n* long short-term memory (LSTM) nodes, where *n* is the number of variables in the model

# Results

## *E. coli* prediction

### Predisinfection *E. coli*

A few data transformations were used to improve model fit: 
* average process data to better represent *E. coli* sampling conditions, ranging from 15-minutes to 24-hours
* log~10~-transform of *E. coli*
* lag *E. coli* by 2-days
While *E. coli* is more highly correlated to the previous *E. coli* observation (1-day), the average time from when a sample is taken to a result is 2-days. Thus, to simulate the use of this model in "real-time" a lag of 2 observations was used. 

A common problem in machine learning is *overfitting*. Overfitting occurs when the model-building method continues to adjust model parameters beyond the general trends and instead fits to error within the training dataset. This causes a deceptively high training R^2^, as the testing RMSE is also very high. RMSE can be interpreted as the standard deviation of the unexplained variance and is used to measure testing error here. A good model for real-time prediction minimizes RMSE. Thus, here we examined different number of training periods, from 100-2000. Figure `r fig<-fig+1;fig.s.retrain<-fig;fig.s.retrain` illustrates how R^2^ is not a good predictor of test RMSE. Currently, *E. coli* is 'predicted' by assuming the last known value approximates current conditions. In modeling, this is refered to as *persistence* and is represented as the red, dashed line in Figure `r fig.s.retrain`. Because the model error is less than persistence for 100-750 epochs, and minimized for 100-500 epochs, the ideal number of training epochs being between 100-500.

**Figure `r fig.s.retrain`.** South predisinfection *E. coli* is predicted using a simple RNN, using a various number of epoch (e.g., "re-train" parameter estimations). The red line is the *persistence* RMSE, which is the RMSE calculated from the previously known *E. coli* value. Compared to the model predicted RMSE (black circles), 100-500 training epochs improve upon the current method of estimating *E. coli* (being less than the persistance prediction). 

```{r South Predisinfection E.coli model fit, echo=FALSE}
load(file=file.path(wd.path,"results","Over-under fit","average-log-lag.RData"))
test.average <- obj;rm(obj)
# Compare results:
# lapply(test.average, function(results.list) {
#   lapply(results.list, function(results) {
#     paste("R2 =",mean(results[,1]),", RMSE =",mean((10^results[,2]-10^results[,3])^2)^0.5)
#   })
# })

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean(results[,1])
  }))
})
r2 <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(r2) <- names(test.average)

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean((10^results[,2]-10^results[,3])^2)^0.5
  }))
})
rmse <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    (mean((10^results[,4]-10^results[,3])^2))^0.5
  }))
})
rmse.p <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)

# R2 and Actual RMSE
par(mfrow=c(1,2))
par(mar=c(3.5,4,2, 0.1), family="serif")
data <- do.call("rbind", lapply(1:ncol(r2), function(i) {
  data <- r2[,i]
  data <- data.frame(rep(colnames(r2)[i], nrow(r2)), data)
}))
colnames(data)[1] <- "epoch"
boxplot(data~epoch, data=data, ylab="", xlab="")
points(data)
mtext("Model R-squared", side=2, line=2.25)
par(mar=c(3.5,4,2, 0.1), family="serif")
data <- do.call("rbind", lapply(1:ncol(rmse), function(i) {
  data <- rmse[,i]
  data <- data.frame(rep(colnames(rmse)[i], nrow(rmse)), data)
}))
colnames(data)[1] <- "epoch"
boxplot(data~epoch, data=data, ylab="", xlab="")
points(data)
abline(h=rmse.p[1,1], col="red", lty=2, lwd=2)
mtext("Test RMSE", side=2, line=2.25)
mtext("Number of times model is re-trained", side=1, line=-1, outer=TRUE)
mtext("South predisinfection E. coli: averaged, log-transformed, lagged", side=3, font=2, line=-1,  outer=TRUE)

## Narrow boxplot ranges by increasing number of model iterations from 10->100
```

```{r North Predisinfection E.coli model fit, echo=FALSE}
# ADD WHEN innov-R server is complete with north analysis
load(file=file.path(wd.path,"results","Over-under fit","average-log-lag-north.RData"))
test.average <- obj;rm(obj)
# Compare results:
# lapply(test.average, function(results.list) {
#   lapply(results.list, function(results) {
#     paste("R2 =",mean(results[,1]),", RMSE =",mean((10^results[,2]-10^results[,3])^2)^0.5)
#   })
# })

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean(results[,1])
  }))
})
r2 <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(r2) <- names(test.average)

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean((10^results[,2]-10^results[,3])^2)^0.5
  }))
})
rmse <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)

l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    (mean((10^results[,4]-10^results[,3])^2))^0.5
  }))
})
rmse.p <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)


# R2 and Actual RMSE
par(mfrow=c(1,2))
par(mar=c(3.5,4,2, 0.1), family="serif")
data <- do.call("rbind", lapply(1:ncol(r2), function(i) {
  data <- r2[,i]
  data <- data.frame(rep(colnames(r2)[i], nrow(r2)), data)
}))
colnames(data)[1] <- "epoch"
boxplot(data~epoch, data=data, ylab="", xlab="")
points(data)
mtext("Model R-squared", side=2, line=2.25)
par(mar=c(3.5,4,2, 0.1), family="serif")
data <- do.call("rbind", lapply(1:ncol(rmse), function(i) {
  data <- rmse[,i]
  data <- data.frame(rep(colnames(rmse)[i], nrow(rmse)), data)
}))
colnames(data)[1] <- "epoch"
boxplot(data~epoch, data=data, ylab="", xlab="")
points(data)
abline(h=rmse.p[1,1], col="red", lty=2, lwd=2)
mtext("Test RMSE", side=2, line=2.25)
mtext("Number of times model is re-trained", side=1, line=-1, outer=TRUE)
mtext("North predisinfection E. coli: averaged, log-transformed, lagged", side=3, font=2, line=-1,  outer=TRUE)


## Narrow boxplot ranges by increasing number of model iterations from 10->100
```

In Figure `r fig<-fig+1;fig.s.best<-fig;fig.s.best`, the best performing model predictions (lowest test RMSE) used are plotted alongside the actual *E. coli* for the entire testing period. For the majority of the testing period, the errors are relatively low, exept for an event on February 25, 2020. 

```{r South Predisinfection E.coli model performance, echo=FALSE}
load(file=file.path(wd.path,"results","Over-under fit","average-log-lag.RData"))
test.average <- obj;rm(obj)
l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean((10^results[,2]-10^results[,3])^2)^0.5
  }))
})
rmse <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)
results <- test.average[[(ceiling(which(rmse==min(rmse))/nrow(rmse)))]][[(which(rmse==min(rmse)) %% nrow(rmse))]]

# plot(results$R2, main="R2", pch=20)

r2 <- mean(results$R2)
rmse.log <- data.frame("Prediction"=mean((results$Prediction-results$Actual)^2)^0.5,
                       "Persistance"=mean((results$Persistance-results$Actual)^2)^0.5)
rmse <- data.frame("Prediction"=mean((10^results$Prediction-10^results$Actual)^2)^0.5,
                   "Persistance"=mean((10^results$Persistance-10^results$Actual)^2)^0.5)

source("src/actual-predicted-plot.R")

label <- "South Predisinfection E.coli"
actual <- data.frame(as.POSIXct(rownames(results)), 10^results$Actual)
predicted <- data.frame(as.POSIXct(rownames(results)),10^results$Prediction)
actual.predicted.plot(actual, predicted, label)
mtext(side=3, line=-1, paste("RMSE =",round(rmse$Prediction,0)), adj=1)
mtext(side=2, line=2.25, "E. coli (CFU/mL)")
# 
# label <- "South Log Predisinfection E.coli"
# actual <- data.frame(as.POSIXct(rownames(results)), results$Actual)
# predicted <- data.frame(as.POSIXct(rownames(results)),results$Prediction)
# actual.predicted.plot(actual, predicted, label)
# mtext(side=3, line=-1, paste("RMSE =",round(rmse.log$Prediction,2)), adj=1)
#   
# plot(x=10^results$Actual, y=10^results$Prediction, pch=20, main="South Predisinfection E.coli", xlab="Actual", ylab="Predicted");abline(a=0,b=1)
```

```{r North Predisinfection E.coli model performance, echo=FALSE}
load(file=file.path(wd.path,"results","Over-under fit","average-log-lag-north.RData"))
test.average <- obj;rm(obj)
l <- lapply(test.average, function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean((10^results[,2]-10^results[,3])^2)^0.5
  }))
})
rmse <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)
results <- test.average[[(ceiling(which(rmse==min(rmse))/nrow(rmse)))]][[(which(rmse==min(rmse)) %% nrow(rmse))]]

# plot(results$R2, main="R2", pch=20)

r2 <- mean(results$R2)
rmse.log <- data.frame("Prediction"=mean((results$Prediction-results$Actual)^2)^0.5,
                       "Persistance"=mean((results$Persistance-results$Actual)^2)^0.5)
rmse <- data.frame("Prediction"=mean((10^results$Prediction-10^results$Actual)^2)^0.5,
                   "Persistance"=mean((10^results$Persistance-10^results$Actual)^2)^0.5)

source("src/actual-predicted-plot.R")

label <- "North Predisinfection E.coli"
actual <- data.frame(as.POSIXct(rownames(results)), 10^results$Actual)
predicted <- data.frame(as.POSIXct(rownames(results)),10^results$Prediction)
actual.predicted.plot(actual, predicted, label)
mtext(side=3, line=-1, paste("RMSE =",round(rmse$Prediction,0)), adj=1)
# 
# label <- "North Log Predisinfection E.coli"
# actual <- data.frame(as.POSIXct(rownames(results)), results$Actual)
# predicted <- data.frame(as.POSIXct(rownames(results)),results$Prediction)
# actual.predicted.plot(actual, predicted, label)
# mtext(side=3, line=-1, paste("RMSE =",round(rmse.log$Prediction,2)), adj=1)
#   
# plot(x=10^results$Actual, y=10^results$Prediction, pch=20, main="North Predisinfection E.coli", xlab="Actual", ylab="Predicted");abline(a=0,b=1)
```


<!-- ### Postdisinfection *E. coli* -->

```{r South Predisinfection Ecoli model performance, eval=FALSE, include=FALSE}
load(file=file.path(wd.path,"results","Over-under fit","average-log-lag-south-postdis.RData"))
test.average <- obj;rm(obj)
l <- lapply(list(test.average), function(results.list) {
  unlist(lapply(results.list, function(results) {
    mean((10^results[,2]-10^results[,3])^2)^0.5
  }))
})
rmse <- data.frame(matrix(unlist(l), nrow=length(l[[1]]), byrow=F),stringsAsFactors=FALSE)
colnames(rmse) <- names(test.average)
# results <- list(test.average)[[(ceiling(which(rmse==min(rmse))/nrow(rmse)))]][[(which(rmse==min(rmse)) %% nrow(rmse))]]
results <- 

# plot(results$R2, main="R2", pch=20)

r2 <- mean(results$R2)
rmse.log <- data.frame("Prediction"=mean((results$Prediction-results$Actual)^2)^0.5,
                       "Persistance"=mean((results$Persistance-results$Actual)^2)^0.5)
rmse <- data.frame("Prediction"=mean((10^results$Prediction-10^results$Actual)^2)^0.5,
                   "Persistance"=mean((10^results$Persistance-10^results$Actual)^2)^0.5)

source("src/actual-predicted-plot.R")

label <- "South Predisinfection E.coli"
actual <- data.frame(as.POSIXct(rownames(results)), 10^results$Actual)
predicted <- data.frame(as.POSIXct(rownames(results)),10^results$Prediction)
actual.predicted.plot(actual, predicted, label)
mtext(side=3, line=-1, paste("RMSE =",round(rmse$Prediction,0)), adj=1)
mtext(side=2, line=2.25, "E. coli (CFU/mL)")
# 
# label <- "South Log Predisinfection E.coli"
# actual <- data.frame(as.POSIXct(rownames(results)), results$Actual)
# predicted <- data.frame(as.POSIXct(rownames(results)),results$Prediction)
# actual.predicted.plot(actual, predicted, label)
# mtext(side=3, line=-1, paste("RMSE =",round(rmse.log$Prediction,2)), adj=1)
#   
# plot(x=10^results$Actual, y=10^results$Prediction, pch=20, main="South Predisinfection E.coli", xlab="Actual", ylab="Predicted");abline(a=0,b=1)
```


### Log removal
```{r}
# Plot -log(Nt/N0), predicted (persistence using excel for constant parameters and neural network using r for real time parameters) and actual
```

### Sensitivity analysis
```{r}
# Plot input variable vs output variable for variety of conditions
```

